{
  "subject": "04-security-general",
  "subjectName": "정보보안 일반",
  "chapter": "01-cryptography",
  "chapterName": "암호학",
  "questions": [
    {
      "id": 1,
      "question": "암호학의 목표 중 인가된 사용자만 정보를 열람할 수 있도록 하는 것은?",
      "options": [
        "부인방지",
        "인증",
        "무결성",
        "기밀성"
      ],
      "answer": 3,
      "explanation": "기밀성(Confidentiality)은 인가된 사용자만 정보를 열람할 수 있도록 보장하는 것으로, 암호화를 통해 구현됩니다.",
      "keywords": [
        "기밀성",
        "Confidentiality"
      ]
    },
    {
      "id": 2,
      "question": "Kerckhoffs의 원칙에 따르면 암호 시스템의 안전성은 무엇에 의존해야 하는가?",
      "options": [
        "프로토콜의 복잡성",
        "알고리즘의 비밀성",
        "키의 비밀성",
        "시스템의 물리적 보안"
      ],
      "answer": 2,
      "explanation": "Kerckhoffs의 원칙은 암호 시스템의 안전성이 알고리즘이 아닌 키의 비밀성에만 의존해야 한다는 현대 암호학의 기본 원칙입니다.",
      "keywords": [
        "Kerckhoffs",
        "키의 비밀성"
      ]
    },
    {
      "id": 3,
      "question": "대칭키 암호에서 n명의 사용자가 통신할 때 필요한 키의 수는?",
      "options": [
        "2n개",
        "n(n-1)/2개",
        "n개",
        "n²개"
      ],
      "answer": 1,
      "explanation": "대칭키 암호에서 n명이 1:1 통신하려면 n(n-1)/2개의 키가 필요합니다. 이것이 대칭키의 키 분배 문제입니다.",
      "keywords": [
        "대칭키",
        "키 분배 문제"
      ]
    },
    {
      "id": 4,
      "question": "AES 암호 알고리즘의 블록 크기와 구조는?",
      "options": [
        "128비트, 페이스텔 구조",
        "64비트, 페이스텔 구조",
        "256비트, SPN 구조",
        "128비트, SPN 구조"
      ],
      "answer": 2,
      "explanation": "AES는 128비트 블록 크기에 SPN(Substitution-Permutation Network) 구조를 사용합니다. 키 길이는 128/192/256비트입니다.",
      "keywords": [
        "AES",
        "SPN",
        "128비트"
      ]
    },
    {
      "id": 5,
      "question": "DES 암호 알고리즘의 특징으로 올바른 것은?",
      "options": [
        "128비트 블록, SPN 구조",
        "64비트 블록, 페이스텔 구조, 56비트 키",
        "128비트 블록, 페이스텔 구조",
        "64비트 블록, SPN 구조, 128비트 키"
      ],
      "answer": 1,
      "explanation": "DES는 64비트 블록, 56비트 키, 페이스텔(Feistel) 구조로 16라운드를 수행합니다. 현재는 키 길이가 짧아 취약합니다.",
      "keywords": [
        "DES",
        "페이스텔",
        "56비트"
      ]
    },
    {
      "id": 6,
      "question": "페이스텔(Feistel) 구조의 특징으로 올바른 것은?",
      "options": [
        "스트림 암호에만 사용된다",
        "복호화 시 역연산이 필요하다",
        "암호화와 복호화 구조가 동일하고 라운드 키 순서만 반대이다",
        "치환과 순열을 조합한 구조이다"
      ],
      "answer": 2,
      "explanation": "페이스텔 구조는 암호화와 복호화 구조가 동일하며, 라운드 키의 적용 순서만 반대입니다. DES, SEED 등에서 사용됩니다.",
      "keywords": [
        "페이스텔",
        "Feistel"
      ]
    },
    {
      "id": 7,
      "question": "한국 표준 암호 알고리즘 중 SPN 구조를 사용하는 것은?",
      "options": [
        "ARIA",
        "RC4",
        "DES",
        "SEED"
      ],
      "answer": 4,
      "explanation": "ARIA는 한국 표준 블록 암호로 SPN 구조를 사용합니다. SEED도 한국 표준이지만 페이스텔 구조입니다.",
      "keywords": [
        "ARIA",
        "한국 표준",
        "SPN"
      ]
    },
    {
      "id": 8,
      "question": "IoT 환경에 적합한 경량 암호 알고리즘으로 한국에서 개발된 것은?",
      "options": [
        "ARIA",
        "SEED",
        "AES",
        "LEA"
      ],
      "answer": 1,
      "explanation": "LEA(Lightweight Encryption Algorithm)는 IoT 환경에 최적화된 한국 경량 블록 암호입니다. 128비트 블록, 128/192/256비트 키를 지원합니다.",
      "keywords": [
        "LEA",
        "경량 암호",
        "IoT"
      ]
    },
    {
      "id": 9,
      "question": "블록 암호 운용 모드 중 각 블록을 독립적으로 암호화하여 패턴이 노출되는 방식은?",
      "options": [
        "CBC",
        "ECB",
        "GCM",
        "CTR"
      ],
      "answer": 1,
      "explanation": "ECB(Electronic Codebook)는 각 블록을 독립적으로 암호화합니다. 같은 평문 블록은 같은 암호문이 되어 패턴이 노출되므로 사용이 비권장됩니다.",
      "keywords": [
        "ECB",
        "패턴 노출"
      ]
    },
    {
      "id": 10,
      "question": "블록 암호 운용 모드 중 이전 암호문 블록과 XOR한 후 암호화하는 방식은?",
      "options": [
        "CTR",
        "CBC",
        "ECB",
        "OFB"
      ],
      "answer": 3,
      "explanation": "CBC(Cipher Block Chaining)는 현재 평문 블록을 이전 암호문 블록과 XOR한 후 암호화합니다. 첫 블록은 IV(초기화 벡터)를 사용합니다.",
      "keywords": [
        "CBC",
        "Cipher Block Chaining",
        "IV"
      ]
    },
    {
      "id": 11,
      "question": "블록 암호 운용 모드 중 병렬 처리가 가능하고 기밀성과 무결성을 동시에 제공하는 것은?",
      "options": [
        "CTR",
        "CBC",
        "ECB",
        "GCM"
      ],
      "answer": 1,
      "explanation": "GCM(Galois/Counter Mode)은 CTR 모드에 인증 태그를 결합하여 기밀성과 무결성을 동시에 제공합니다. TLS 1.3에서 주로 사용됩니다.",
      "keywords": [
        "GCM",
        "기밀성",
        "무결성"
      ]
    },
    {
      "id": 12,
      "question": "스트림 암호 중 TLS 1.3에서 사용되는 현대적 알고리즘은?",
      "options": [
        "DES",
        "ChaCha20",
        "RC4",
        "A5/1"
      ],
      "answer": 4,
      "explanation": "ChaCha20는 모바일 환경에 최적화된 현대적 스트림 암호로, TLS 1.3에서 사용됩니다. RC4는 취약하여 사용이 금지되었습니다.",
      "keywords": [
        "ChaCha20",
        "스트림 암호",
        "TLS 1.3"
      ]
    },
    {
      "id": 13,
      "question": "비대칭키(공개키) 암호의 특징으로 올바르지 않은 것은?",
      "options": [
        "키 분배 문제를 해결한다",
        "주로 키 교환과 전자서명에 사용된다",
        "대칭키보다 암호화 속도가 빠르다",
        "공개키와 개인키 쌍을 사용한다"
      ],
      "answer": 1,
      "explanation": "비대칭키 암호는 대칭키보다 1000배 이상 느립니다. 따라서 대용량 데이터 암호화에는 부적합하며, 주로 키 교환과 전자서명에 사용됩니다.",
      "keywords": [
        "비대칭키",
        "속도"
      ]
    },
    {
      "id": 14,
      "question": "RSA 알고리즘의 수학적 기반은?",
      "options": [
        "큰 수의 소인수분해 어려움",
        "배낭 문제",
        "이산 대수 문제",
        "타원곡선 이산 대수 문제"
      ],
      "answer": 3,
      "explanation": "RSA는 큰 수의 소인수분해가 어렵다는 수학적 문제에 기반합니다. 두 큰 소수 p, q의 곱 n에서 p, q를 찾기 어려운 성질을 이용합니다.",
      "keywords": [
        "RSA",
        "소인수분해"
      ]
    },
    {
      "id": 15,
      "question": "RSA에서 현재 권장되는 최소 키 길이는?",
      "options": [
        "1024비트",
        "2048비트",
        "512비트",
        "4096비트"
      ],
      "answer": 1,
      "explanation": "RSA는 현재 최소 2048비트 이상을 권장합니다. 장기 보안은 3072비트, 최고 보안은 4096비트가 권장됩니다.",
      "keywords": [
        "RSA",
        "2048비트",
        "키 길이"
      ]
    },
    {
      "id": 16,
      "question": "ElGamal 알고리즘의 수학적 기반은?",
      "options": [
        "최단 벡터 문제",
        "소인수분해 문제",
        "이산 대수 문제 (DLP)",
        "타원곡선 문제"
      ],
      "answer": 2,
      "explanation": "ElGamal은 이산 대수 문제(Discrete Logarithm Problem)에 기반합니다. y = g^x mod p에서 x를 찾기 어려운 성질을 이용합니다.",
      "keywords": [
        "ElGamal",
        "이산 대수"
      ]
    },
    {
      "id": 17,
      "question": "ECC(타원곡선 암호)의 장점으로 올바른 것은?",
      "options": [
        "대칭키 암호보다 빠르다",
        "짧은 키 길이로 RSA와 동등한 보안 강도를 제공한다",
        "RSA보다 키 길이가 길다",
        "양자 컴퓨터에 안전하다"
      ],
      "answer": 3,
      "explanation": "ECC는 RSA보다 훨씬 짧은 키로 동등한 보안 강도를 제공합니다. RSA 2048비트와 ECC 224비트가 동등합니다. 모바일/IoT에 적합합니다.",
      "keywords": [
        "ECC",
        "타원곡선",
        "짧은 키"
      ]
    },
    {
      "id": 18,
      "question": "RSA 3072비트와 동등한 보안 강도를 제공하는 ECC 키 길이는?",
      "options": [
        "160비트",
        "384비트",
        "256비트",
        "224비트"
      ],
      "answer": 4,
      "explanation": "RSA 3072비트 ≈ ECC 256비트 ≈ 대칭키 128비트의 보안 강도를 제공합니다. ECC는 훨씬 짧은 키로 동등한 보안을 달성합니다.",
      "keywords": [
        "ECC",
        "키 길이 비교"
      ]
    },
    {
      "id": 19,
      "question": "Diffie-Hellman 키 교환의 취약점은?",
      "options": [
        "중간자 공격 (MITM)",
        "충돌 공격",
        "소인수분해 공격",
        "사전 공격"
      ],
      "answer": 3,
      "explanation": "Diffie-Hellman은 인증 기능이 없어 중간자 공격(MITM)에 취약합니다. 이를 방지하려면 인증을 추가해야 합니다.",
      "keywords": [
        "Diffie-Hellman",
        "MITM"
      ]
    },
    {
      "id": 20,
      "question": "해시 함수의 특성 중 H(x) = h가 주어졌을 때 x를 찾기 어려운 성질은?",
      "options": [
        "제2역상 저항성",
        "일방향성",
        "충돌 저항성",
        "역상 저항성"
      ],
      "answer": 3,
      "explanation": "역상 저항성(Preimage Resistance)은 해시값 h에서 원본 x를 찾기 어려운 특성입니다. 해시 함수의 일방향성을 보장합니다.",
      "keywords": [
        "역상 저항성",
        "Preimage Resistance"
      ]
    },
    {
      "id": 21,
      "question": "해시 함수에서 H(x) = H(y)인 서로 다른 x, y 쌍을 찾기 어려운 특성은?",
      "options": [
        "역상 저항성",
        "확산성",
        "제2역상 저항성",
        "충돌 저항성"
      ],
      "answer": 3,
      "explanation": "충돌 저항성(Collision Resistance)은 같은 해시값을 가지는 두 서로 다른 입력을 찾기 어려운 특성입니다.",
      "keywords": [
        "충돌 저항성",
        "Collision Resistance"
      ]
    },
    {
      "id": 22,
      "question": "현재 안전하다고 평가되는 해시 알고리즘은?",
      "options": [
        "MD5",
        "SHA-1",
        "SHA-256",
        "CRC32"
      ],
      "answer": 2,
      "explanation": "SHA-256은 현재 안전하고 널리 사용됩니다. MD5(128비트)와 SHA-1(160비트)은 충돌이 발견되어 취약합니다.",
      "keywords": [
        "SHA-256",
        "안전한 해시"
      ]
    },
    {
      "id": 23,
      "question": "비밀번호 해싱에서 레인보우 테이블 공격을 방지하기 위해 추가하는 랜덤 값은?",
      "options": [
        "넌스(Nonce)",
        "IV",
        "페퍼(Pepper)",
        "솔트(Salt)"
      ],
      "answer": 3,
      "explanation": "솔트(Salt)는 비밀번호 해싱 시 추가되는 랜덤 값으로, 각 사용자별 다른 해시를 생성하여 레인보우 테이블 공격을 방지합니다.",
      "keywords": [
        "솔트",
        "Salt",
        "레인보우 테이블"
      ]
    },
    {
      "id": 24,
      "question": "비밀번호 해싱에서 해시를 여러 번 반복하여 무차별 대입 공격을 어렵게 하는 기법은?",
      "options": [
        "키 스트레칭",
        "패딩",
        "솔팅",
        "인코딩"
      ],
      "answer": 3,
      "explanation": "키 스트레칭(Key Stretching)은 해시 함수를 수천~수만 번 반복 적용하여 공격자의 무차별 대입 시도를 느리게 만드는 기법입니다.",
      "keywords": [
        "키 스트레칭",
        "Key Stretching"
      ]
    },
    {
      "id": 25,
      "question": "MAC(메시지 인증 코드)이 제공하는 보안 기능은?",
      "options": [
        "무결성과 인증",
        "기밀성만",
        "부인방지만",
        "기밀성과 부인방지"
      ],
      "answer": 2,
      "explanation": "MAC은 비밀키를 사용하여 메시지의 무결성(변조 탐지)과 인증(송신자 확인)을 제공합니다. 부인방지는 제공하지 않습니다.",
      "keywords": [
        "MAC",
        "무결성",
        "인증"
      ]
    },
    {
      "id": 26,
      "question": "해시 기반 MAC의 가장 널리 사용되는 구현은?",
      "options": [
        "PMAC",
        "HMAC",
        "CMAC",
        "GMAC"
      ],
      "answer": 4,
      "explanation": "HMAC(Hash-based MAC)은 해시 함수를 기반으로 하는 MAC으로, HMAC-SHA256이 가장 널리 사용됩니다.",
      "keywords": [
        "HMAC",
        "Hash-based MAC"
      ]
    },
    {
      "id": 27,
      "question": "전자서명이 제공하는 보안 기능의 조합으로 올바른 것은?",
      "options": [
        "기밀성, 가용성",
        "인증, 가용성",
        "인증, 무결성, 부인방지",
        "기밀성, 무결성"
      ],
      "answer": 1,
      "explanation": "전자서명은 개인키로 서명하고 공개키로 검증하여 인증(신원 확인), 무결성(변조 탐지), 부인방지(행위 부인 방지)를 제공합니다.",
      "keywords": [
        "전자서명",
        "인증",
        "무결성",
        "부인방지"
      ]
    },
    {
      "id": 28,
      "question": "전자서명에서 메시지 해시를 개인키로 암호화하는 이유는?",
      "options": [
        "서명 검증이 불가능하기 때문",
        "메시지 전체를 암호화하면 속도가 느리기 때문",
        "해시가 암호화보다 안전하기 때문",
        "공개키로는 암호화할 수 없기 때문"
      ],
      "answer": 2,
      "explanation": "비대칭키 암호화는 매우 느리므로, 메시지 전체 대신 고정 길이의 해시값만 개인키로 서명하여 효율성을 높입니다.",
      "keywords": [
        "전자서명",
        "해시",
        "효율성"
      ]
    },
    {
      "id": 29,
      "question": "서명 전용으로 설계된 전자서명 알고리즘은?",
      "options": [
        "RSA",
        "DH",
        "DSA",
        "AES"
      ],
      "answer": 1,
      "explanation": "DSA(Digital Signature Algorithm)는 서명 전용 알고리즘입니다. RSA는 암호화와 서명 모두 가능하지만, DSA는 서명만 가능합니다.",
      "keywords": [
        "DSA",
        "서명 전용"
      ]
    },
    {
      "id": 30,
      "question": "PKI(공개키 기반구조)에서 인증서를 발급하고 폐지하는 역할을 하는 것은?",
      "options": [
        "RA (등록기관)",
        "Repository",
        "OCSP Responder",
        "CA (인증기관)"
      ],
      "answer": 1,
      "explanation": "CA(Certificate Authority, 인증기관)는 공개키 인증서를 발급하고 폐지하는 역할을 합니다. RA는 사용자 등록과 신원 확인을 담당합니다.",
      "keywords": [
        "CA",
        "인증기관",
        "PKI"
      ]
    },
    {
      "id": 31,
      "question": "인증서 폐지 상태를 실시간으로 조회하는 프로토콜은?",
      "options": [
        "LDAP",
        "CRL",
        "X.500",
        "OCSP"
      ],
      "answer": 2,
      "explanation": "OCSP(Online Certificate Status Protocol)는 인증서 폐지 상태를 실시간으로 조회합니다. CRL은 폐지 목록을 주기적으로 배포하는 방식입니다.",
      "keywords": [
        "OCSP",
        "인증서 폐지"
      ]
    },
    {
      "id": 32,
      "question": "X.509 인증서에 포함되지 않는 항목은?",
      "options": [
        "발급자(Issuer)",
        "유효기간",
        "공개키 정보",
        "개인키"
      ],
      "answer": 2,
      "explanation": "X.509 인증서에는 공개키, 유효기간, 발급자, 주체, 서명 등이 포함되지만, 개인키는 절대 포함되지 않습니다.",
      "keywords": [
        "X.509",
        "인증서 구조"
      ]
    },
    {
      "id": 33,
      "question": "TLS 1.3에서 필수로 적용된 보안 특성으로 장기 비밀키가 노출되어도 과거 세션 키가 안전한 것은?",
      "options": [
        "OCSP Stapling",
        "CRL",
        "PFS (Perfect Forward Secrecy)",
        "Certificate Pinning"
      ],
      "answer": 2,
      "explanation": "PFS(Perfect Forward Secrecy)는 장기 비밀키가 노출되어도 과거에 생성된 세션 키는 안전하게 유지되는 특성입니다. TLS 1.3에서 필수입니다.",
      "keywords": [
        "PFS",
        "Perfect Forward Secrecy"
      ]
    },
    {
      "id": 34,
      "question": "TLS 1.3에서 제거된 취약한 요소가 아닌 것은?",
      "options": [
        "RSA 키 교환",
        "ECDHE 키 교환",
        "SHA-1",
        "CBC 모드"
      ],
      "answer": 4,
      "explanation": "TLS 1.3에서는 RSA 키 교환, CBC 모드 등 취약한 요소가 제거되었습니다. ECDHE는 PFS를 제공하는 안전한 키 교환 방식으로 유지됩니다.",
      "keywords": [
        "TLS 1.3",
        "개선사항"
      ]
    },
    {
      "id": 35,
      "question": "IPsec에서 기밀성, 인증, 무결성을 모두 제공하는 프로토콜은?",
      "options": [
        "IKE",
        "ESP",
        "AH",
        "ISAKMP"
      ],
      "answer": 3,
      "explanation": "ESP(Encapsulating Security Payload)는 기밀성, 인증, 무결성을 제공합니다. AH는 인증과 무결성만 제공하고 암호화는 하지 않습니다.",
      "keywords": [
        "ESP",
        "IPsec"
      ]
    },
    {
      "id": 36,
      "question": "IPsec의 운영 모드 중 전체 IP 패킷을 보호하는 모드는?",
      "options": [
        "전송 모드",
        "터널 모드",
        "혼합 모드",
        "브릿지 모드"
      ],
      "answer": 1,
      "explanation": "터널 모드는 원본 IP 헤더를 포함한 전체 IP 패킷을 보호합니다. 전송 모드는 IP 페이로드만 보호합니다. VPN에서 주로 터널 모드를 사용합니다.",
      "keywords": [
        "터널 모드",
        "IPsec"
      ]
    },
    {
      "id": 37,
      "question": "무선 보안 프로토콜 중 AES-CCMP를 사용하며 현재 안전한 것은?",
      "options": [
        "WPA2",
        "WEP2",
        "WPA",
        "WEP"
      ],
      "answer": 3,
      "explanation": "WPA2는 AES-CCMP 암호화를 사용하여 현재 안전합니다. WEP는 RC4, WPA는 TKIP(RC4)를 사용하여 취약합니다.",
      "keywords": [
        "WPA2",
        "AES-CCMP"
      ]
    },
    {
      "id": 38,
      "question": "암호 분석에서 공격자가 일부 평문-암호문 쌍을 알고 있는 공격 유형은?",
      "options": [
        "암호문 단독 공격",
        "선택 평문 공격",
        "선택 암호문 공격",
        "기지 평문 공격"
      ],
      "answer": 1,
      "explanation": "기지 평문 공격(Known Plaintext Attack)은 공격자가 일부 평문-암호문 쌍을 알고 있을 때 키를 추출하는 공격입니다.",
      "keywords": [
        "기지 평문 공격",
        "Known Plaintext"
      ]
    },
    {
      "id": 39,
      "question": "암호 구현의 타이밍, 전력 소비, 전자파 등을 분석하여 키를 추출하는 공격은?",
      "options": [
        "차분 분석",
        "부채널 공격",
        "생일 공격",
        "선형 분석"
      ],
      "answer": 4,
      "explanation": "부채널 공격(Side-Channel Attack)은 암호 알고리즘의 구현에서 발생하는 타이밍, 전력 소비, 전자파 등 물리적 정보를 분석하여 비밀키를 추출합니다.",
      "keywords": [
        "부채널 공격",
        "Side-Channel"
      ]
    },
    {
      "id": 40,
      "question": "양자 컴퓨팅에서 RSA와 ECC를 무력화할 수 있는 알고리즘은?",
      "options": [
        "RSA 알고리즘",
        "Grover 알고리즘",
        "Dijkstra 알고리즘",
        "Shor 알고리즘"
      ],
      "answer": 2,
      "explanation": "Shor 알고리즘은 양자 컴퓨터에서 소인수분해와 이산 대수 문제를 효율적으로 풀어 RSA, ECC 등을 무력화할 수 있습니다.",
      "keywords": [
        "Shor",
        "양자 컴퓨팅"
      ]
    },
    {
      "id": 41,
      "question": "NIST에서 포스트 양자 암호(PQC) 표준으로 선정된 키 캡슐화 알고리즘은?",
      "options": [
        "RSA",
        "CRYSTALS-Kyber",
        "SPHINCS+",
        "CRYSTALS-Dilithium"
      ],
      "answer": 4,
      "explanation": "CRYSTALS-Kyber는 NIST PQC 표준으로 선정된 키 캡슐화(KEM) 알고리즘입니다. CRYSTALS-Dilithium과 SPHINCS+는 전자서명 알고리즘입니다.",
      "keywords": [
        "CRYSTALS-Kyber",
        "PQC"
      ]
    },
    {
      "id": 42,
      "question": "해시 함수에서 충돌을 찾기 위한 복잡도가 2^(n/2)인 공격은?",
      "options": [
        "역상 공격",
        "레인보우 테이블 공격",
        "생일 공격",
        "사전 공격"
      ],
      "answer": 4,
      "explanation": "생일 공격(Birthday Attack)은 생일 역설을 이용하여 해시 충돌을 찾는 공격으로, n비트 해시에서 약 2^(n/2)의 시도로 충돌을 찾을 수 있습니다.",
      "keywords": [
        "생일 공격",
        "충돌",
        "2^(n/2)"
      ]
    },
    {
      "id": 43,
      "question": "비트코인에서 사용되는 타원곡선은?",
      "options": [
        "NIST P-256",
        "secp256k1",
        "NIST P-384",
        "Curve25519"
      ],
      "answer": 4,
      "explanation": "비트코인은 secp256k1 타원곡선을 사용합니다. NIST P-256은 일반적인 보안 용도, Curve25519는 현대적인 안전한 곡선입니다.",
      "keywords": [
        "secp256k1",
        "비트코인",
        "타원곡선"
      ]
    },
    {
      "id": 44,
      "question": "대칭키 암호와 비대칭키 암호의 비교로 올바르지 않은 것은?",
      "options": [
        "대칭키는 속도가 빠르고, 비대칭키는 느리다",
        "대칭키는 주로 전자서명에 사용된다",
        "대칭키는 키 1개, 비대칭키는 키 2개를 사용한다",
        "대칭키는 키 분배가 어렵고, 비대칭키는 쉽다"
      ],
      "answer": 4,
      "explanation": "전자서명은 비대칭키(공개키) 암호의 주요 용도입니다. 대칭키는 대용량 데이터 암호화에 주로 사용됩니다.",
      "keywords": [
        "대칭키",
        "비대칭키",
        "비교"
      ]
    },
    {
      "id": 45,
      "question": "현재 사용이 금지된 취약한 암호 알고리즘의 조합으로 올바른 것은?",
      "options": [
        "DES, RC4, MD5, SHA-1",
        "ChaCha20, AES-GCM",
        "ARIA, SEED, LEA",
        "AES, SHA-256, RSA-2048"
      ],
      "answer": 4,
      "explanation": "DES(56비트), RC4(편향 취약), MD5(충돌 발견), SHA-1(충돌 발견)은 모두 취약하여 사용이 금지되었습니다.",
      "keywords": [
        "취약 알고리즘",
        "사용 금지"
      ]
    }
  ]
}