{
  "subject": "01-system-security",
  "subjectName": "시스템 보안",
  "chapter": "05-security-threats",
  "chapterName": "시스템 보안위협 및 공격기법",
  "questions": [
    {
      "id": 1,
      "question": "악성코드 유형 중 숙주 파일 없이 독립적으로 실행되며 네트워크를 통해 자가 전파하는 것은?",
      "options": [
        "바이러스",
        "웜",
        "트로이목마",
        "애드웨어"
      ],
      "answer": 1,
      "explanation": "웜(Worm)은 숙주 파일 없이 독립적으로 실행되며 네트워크 취약점을 이용하여 자가 전파합니다. 바이러스는 숙주 파일이 필요합니다.",
      "keywords": [
        "웜",
        "자가 전파",
        "악성코드"
      ]
    },
    {
      "id": 2,
      "question": "APT(Advanced Persistent Threat) 공격 단계인 Cyber Kill Chain의 올바른 순서는?",
      "options": [
        "전달 → 정찰 → 무기화 → 취약점 공격 → C2 → 설치 → 목표 달성",
        "정찰 → 무기화 → 전달 → 취약점 공격 → 설치 → C2 → 목표 달성",
        "무기화 → 정찰 → 전달 → 설치 → 취약점 공격 → C2 → 목표 달성",
        "정찰 → 전달 → 무기화 → 취약점 공격 → C2 → 설치 → 목표 달성"
      ],
      "answer": 2,
      "explanation": "Cyber Kill Chain은 정찰(Reconnaissance) → 무기화(Weaponization) → 전달(Delivery) → 취약점 공격(Exploitation) → 설치(Installation) → C2 → 목표 달성(Actions) 7단계입니다.",
      "keywords": [
        "Cyber Kill Chain",
        "APT",
        "공격 단계"
      ]
    },
    {
      "id": 3,
      "question": "버퍼 오버플로우 방어 기법 중 데이터 영역에서 코드 실행을 금지하는 것은?",
      "options": [
        "DEP/NX",
        "ASLR",
        "PIE",
        "Stack Canary"
      ],
      "answer": 4,
      "explanation": "DEP(Data Execution Prevention)/NX(No Execute)는 스택, 힙 등 데이터 영역에서 코드 실행을 금지하여 쉘코드 실행을 방지합니다.",
      "keywords": [
        "DEP",
        "NX",
        "버퍼 오버플로우 방어"
      ]
    },
    {
      "id": 4,
      "question": "ASLR(Address Space Layout Randomization)의 목적은?",
      "options": [
        "스택에 랜덤 값을 삽입하여 오버플로우를 탐지한다",
        "안전한 함수를 사용하도록 강제한다",
        "데이터 영역의 코드 실행을 금지한다",
        "메모리 주소를 무작위화하여 주소 예측을 방지한다"
      ],
      "answer": 1,
      "explanation": "ASLR은 프로세스의 스택, 힙, 라이브러리 등의 메모리 주소를 무작위로 배치하여 공격자가 특정 메모리 주소를 예측하기 어렵게 합니다.",
      "keywords": [
        "ASLR",
        "주소 무작위화",
        "메모리 보호"
      ]
    },
    {
      "id": 5,
      "question": "SQL Injection 방어 대책으로 가장 효과적인 것은?",
      "options": [
        "입력값 길이 제한",
        "에러 메시지 숨김",
        "WAF 설치",
        "Prepared Statement(파라미터화된 쿼리)"
      ],
      "answer": 2,
      "explanation": "Prepared Statement는 SQL 쿼리와 데이터를 분리하여 처리하므로, 사용자 입력이 SQL 구문으로 해석되지 않아 가장 근본적인 SQL Injection 방어 대책입니다.",
      "keywords": [
        "Prepared Statement",
        "SQL Injection",
        "파라미터화 쿼리"
      ]
    },
    {
      "id": 6,
      "question": "XSS 공격 유형 중 악성 스크립트가 서버 DB에 저장되어 다른 사용자가 열람할 때 실행되는 것은?",
      "options": [
        "Self-XSS",
        "DOM-based XSS",
        "Reflected XSS",
        "Stored XSS"
      ],
      "answer": 3,
      "explanation": "Stored XSS(저장형 XSS)는 게시판 등에 악성 스크립트가 저장되어, 해당 페이지를 열람하는 다른 사용자의 브라우저에서 실행됩니다.",
      "keywords": [
        "Stored XSS",
        "저장형",
        "XSS"
      ]
    },
    {
      "id": 7,
      "question": "CSRF(Cross-Site Request Forgery) 공격의 방어 대책으로 가장 적절한 것은?",
      "options": [
        "출력 인코딩(HTML Entity 변환)",
        "Content Security Policy 헤더",
        "CSRF 토큰(Anti-CSRF Token)",
        "입력값 화이트리스트 검증"
      ],
      "answer": 2,
      "explanation": "CSRF 토큰은 요청마다 고유한 토큰을 생성하여 정상적인 요청인지 검증합니다. 출력 인코딩과 CSP는 XSS 방어에 해당합니다.",
      "keywords": [
        "CSRF 토큰",
        "Anti-CSRF",
        "요청 위조 방어"
      ]
    },
    {
      "id": 8,
      "question": "MITRE ATT&CK 프레임워크에서 공격자가 내부 네트워크의 다른 시스템으로 이동하는 전술(Tactic)은?",
      "options": [
        "Initial Access",
        "Persistence",
        "Exfiltration",
        "Lateral Movement"
      ],
      "answer": 2,
      "explanation": "Lateral Movement(측면 이동)는 공격자가 초기 침투 후 내부 네트워크의 다른 시스템으로 이동하는 전술입니다. Pass-the-Hash, PsExec 등이 해당됩니다.",
      "keywords": [
        "Lateral Movement",
        "MITRE ATT&CK",
        "측면 이동"
      ]
    },
    {
      "id": 9,
      "question": "랜섬웨어 대응의 3-2-1 백업 규칙에서 '1'이 의미하는 것은?",
      "options": [
        "1개의 미디어 유형",
        "1일 1회 백업",
        "1개의 데이터 사본",
        "1개는 오프사이트(원격지) 보관"
      ],
      "answer": 1,
      "explanation": "3-2-1 규칙: 데이터 사본 3개, 2개의 다른 미디어 유형, 1개는 오프사이트(물리적으로 분리된 장소) 보관입니다.",
      "keywords": [
        "3-2-1 규칙",
        "백업",
        "랜섬웨어"
      ]
    },
    {
      "id": 10,
      "question": "취약점 심각도를 0.0~10.0 점수로 나타내는 표준 시스템은?",
      "options": [
        "CVE",
        "CVSS",
        "CWE",
        "NVD"
      ],
      "answer": 3,
      "explanation": "CVSS(Common Vulnerability Scoring System)는 취약점의 심각도를 0.0~10.0 점수로 나타냅니다. 9.0~10.0은 Critical, 7.0~8.9는 High입니다.",
      "keywords": [
        "CVSS",
        "취약점 심각도",
        "점수"
      ]
    },
    {
      "id": 11,
      "question": "다음 중 파일리스 악성코드(Fileless Malware)의 특징으로 옳은 것은?",
      "options": [
        "반드시 이메일 첨부파일로만 전파된다",
        "파일 없이 메모리에서 실행되어 탐지가 어렵다",
        "안티바이러스로 쉽게 탐지된다",
        "디스크에 악성 파일을 저장하여 지속성을 확보한다"
      ],
      "answer": 4,
      "explanation": "파일리스 악성코드는 디스크에 파일을 생성하지 않고 메모리에서 직접 실행됩니다. PowerShell, WMI 등 시스템 도구를 악용하여 탐지가 어렵습니다.",
      "keywords": [
        "파일리스 악성코드",
        "메모리 실행",
        "탐지 회피"
      ]
    },
    {
      "id": 12,
      "question": "버퍼 오버플로우에서 DEP를 우회하기 위해 기존 코드 조각(Gadget)을 체인으로 연결하는 공격 기법은?",
      "options": [
        "Stack Canary 우회",
        "ROP",
        "Return-to-libc",
        "Heap Spray"
      ],
      "answer": 3,
      "explanation": "ROP(Return-Oriented Programming)는 프로그램 내 기존 코드 조각(Gadget)의 리턴 주소를 조작하여 체인으로 연결함으로써 DEP와 ASLR을 우회합니다.",
      "keywords": [
        "ROP",
        "Gadget",
        "DEP 우회"
      ]
    },
    {
      "id": 13,
      "question": "WannaCry 랜섬웨어가 전파에 이용한 SMB 취약점은?",
      "options": [
        "Shellshock",
        "Heartbleed",
        "Log4Shell",
        "EternalBlue"
      ],
      "answer": 1,
      "explanation": "WannaCry(2017)는 NSA에서 유출된 EternalBlue(MS17-010, SMB 취약점)를 이용하여 네트워크를 통해 급속히 전파되었습니다.",
      "keywords": [
        "WannaCry",
        "EternalBlue",
        "SMB"
      ]
    },
    {
      "id": 14,
      "question": "권한 상승 유형 중 일반 사용자가 관리자(root) 권한을 획득하는 것은?",
      "options": [
        "수평적 권한 상승",
        "측면 이동",
        "권한 위임",
        "수직적 권한 상승"
      ],
      "answer": 1,
      "explanation": "수직적 권한 상승(Vertical Privilege Escalation)은 낮은 권한에서 높은 권한(예: user → root)을 획득하는 것입니다. 수평적 권한 상승은 동급 다른 사용자 권한 획득입니다.",
      "keywords": [
        "수직적 권한 상승",
        "Privilege Escalation",
        "root"
      ]
    },
    {
      "id": 15,
      "question": "Linux에서 SUID가 설정된 바이너리를 악용한 권한 상승에 대한 설명으로 옳은 것은?",
      "options": [
        "SUID 바이너리는 항상 현재 사용자의 권한으로 실행된다",
        "SUID는 디렉토리에만 설정 가능하다",
        "SUID 바이너리는 실행 시 파일 소유자의 권한으로 실행된다",
        "SUID는 Linux에서 지원하지 않는다"
      ],
      "answer": 3,
      "explanation": "SUID(Set User ID)가 설정된 바이너리는 실행 시 파일 소유자의 권한으로 실행됩니다. root 소유 SUID 프로그램을 악용하면 root 권한을 획득할 수 있습니다.",
      "keywords": [
        "SUID",
        "권한 상승",
        "Linux"
      ]
    },
    {
      "id": 16,
      "question": "측면 이동(Lateral Movement) 기법 중 NTLM 해시를 사용하여 평문 패스워드 없이 인증하는 것은?",
      "options": [
        "Pass-the-Ticket",
        "Kerberoasting",
        "PsExec",
        "Pass-the-Hash"
      ],
      "answer": 1,
      "explanation": "Pass-the-Hash는 NTLM 해시를 직접 사용하여 인증하므로 평문 패스워드가 필요 없습니다. NTLM Challenge-Response 프로토콜의 특성을 악용합니다.",
      "keywords": [
        "Pass-the-Hash",
        "NTLM 해시",
        "측면 이동"
      ]
    },
    {
      "id": 17,
      "question": "명령어 삽입(Command Injection) 공격에서 사용되는 명령어 구분자가 아닌 것은?",
      "options": [
        "&& (AND)",
        "== (등호)",
        "; (세미콜론)",
        "|| (OR)"
      ],
      "answer": 4,
      "explanation": "==는 비교 연산자이지 명령어 구분자가 아닙니다. ;는 순차 실행, &&는 이전 성공 시 실행, ||는 이전 실패 시 실행되는 명령어 구분자입니다.",
      "keywords": [
        "Command Injection",
        "명령어 구분자",
        "공격"
      ]
    },
    {
      "id": 18,
      "question": "악성코드 분석 유형 중 격리된 환경(샌드박스)에서 악성코드를 실행하여 행위를 관찰하는 것은?",
      "options": [
        "메모리 분석",
        "정적 분석",
        "코드 리뷰",
        "동적 분석"
      ],
      "answer": 2,
      "explanation": "동적 분석은 샌드박스 등 격리 환경에서 악성코드를 실행하여 파일 생성, 레지스트리 변경, 네트워크 통신 등의 행위를 관찰합니다.",
      "keywords": [
        "동적 분석",
        "샌드박스",
        "악성코드 분석"
      ]
    },
    {
      "id": 19,
      "question": "XSS 방어를 위해 웹 페이지에서 실행 가능한 스크립트 소스를 제한하는 HTTP 헤더는?",
      "options": [
        "X-Content-Type-Options",
        "Content-Security-Policy",
        "HSTS",
        "X-Frame-Options"
      ],
      "answer": 4,
      "explanation": "CSP(Content-Security-Policy) 헤더는 스크립트, 스타일, 이미지 등의 허용된 소스를 정의하여 인라인 스크립트 실행이나 외부 악성 스크립트 로딩을 방지합니다.",
      "keywords": [
        "CSP",
        "Content-Security-Policy",
        "XSS 방어"
      ]
    },
    {
      "id": 20,
      "question": "CVE(Common Vulnerabilities and Exposures) 식별자의 형식으로 올바른 것은?",
      "options": [
        "CWE-번호 (예: CWE-89)",
        "CVE-연도-번호 (예: CVE-2021-44228)",
        "NVD-연도-번호 (예: NVD-2021-001)",
        "CVSS-연도-점수 (예: CVSS-2021-9.8)"
      ],
      "answer": 2,
      "explanation": "CVE 식별자는 CVE-연도-번호 형식입니다. 예: CVE-2021-44228(Log4Shell). CWE는 취약점 유형 분류, CVSS는 심각도 점수입니다.",
      "keywords": [
        "CVE",
        "취약점 식별자",
        "형식"
      ]
    },
    {
      "id": 21,
      "question": "위협 주체(Threat Actor) 중 정치적/사회적 목적으로 해킹하는 그룹은?",
      "options": [
        "사이버 범죄자",
        "스크립트 키디",
        "핵티비스트",
        "산업 스파이"
      ],
      "answer": 2,
      "explanation": "핵티비스트(Hacktivist)는 Hacker + Activist의 합성어로, 정치적/사회적 목적으로 웹사이트 변조, DDoS 공격 등을 수행합니다. Anonymous가 대표적입니다.",
      "keywords": [
        "핵티비스트",
        "Hacktivist",
        "위협 주체"
      ]
    },
    {
      "id": 22,
      "question": "SQL Injection 유형 중 참/거짓 응답의 차이로 데이터를 추출하는 방식은?",
      "options": [
        "Error-based",
        "Union-based",
        "Boolean-based Blind",
        "Out-of-band"
      ],
      "answer": 1,
      "explanation": "Boolean-based Blind SQL Injection은 조건문의 참/거짓에 따른 페이지 응답 차이를 이용하여 한 비트씩 데이터를 추출합니다.",
      "keywords": [
        "Blind SQL Injection",
        "Boolean-based",
        "참/거짓"
      ]
    },
    {
      "id": 23,
      "question": "루트킷(Rootkit)의 특징으로 옳은 것은?",
      "options": [
        "광고를 표시하는 악성코드이다",
        "키보드 입력을 기록한다",
        "파일을 암호화하고 금전을 요구한다",
        "시스템 깊숙이 숨어 자신과 다른 악성코드를 은닉한다"
      ],
      "answer": 3,
      "explanation": "루트킷은 커널이나 부트 레벨에서 동작하며 자신과 다른 악성코드의 존재를 시스템에서 은닉합니다. 탐지와 제거가 매우 어렵습니다.",
      "keywords": [
        "루트킷",
        "은닉",
        "커널"
      ]
    },
    {
      "id": 24,
      "question": "Windows 권한 상승 기법 중 공백이 있는 서비스 경로를 악용하는 것은?",
      "options": [
        "UAC 우회",
        "토큰 조작",
        "DLL Hijacking",
        "Unquoted Service Path"
      ],
      "answer": 3,
      "explanation": "Unquoted Service Path는 따옴표 없이 공백이 포함된 서비스 실행 경로에서, Windows가 경로를 잘못 해석하여 공격자의 실행 파일을 먼저 실행하는 취약점입니다.",
      "keywords": [
        "Unquoted Service Path",
        "권한 상승",
        "Windows"
      ]
    },
    {
      "id": 25,
      "question": "스택 버퍼 오버플로우 방어를 위해 스택에 랜덤 값을 삽입하여 변조를 탐지하는 기법은?",
      "options": [
        "Stack Canary",
        "ASLR",
        "CFI",
        "DEP"
      ],
      "answer": 4,
      "explanation": "Stack Canary(카나리)는 스택의 리턴 주소 앞에 랜덤 값을 삽입하여, 버퍼 오버플로우로 리턴 주소를 덮어쓸 때 카나리 값이 변조되면 탐지합니다.",
      "keywords": [
        "Stack Canary",
        "스택 보호",
        "오버플로우 탐지"
      ]
    },
    {
      "id": 26,
      "question": "RaaS(Ransomware as a Service)에 대한 설명으로 옳은 것은?",
      "options": [
        "랜섬웨어 탐지 솔루션이다",
        "랜섬웨어 피해자를 위한 복구 서비스이다",
        "랜섬웨어를 무료로 배포하는 서비스이다",
        "랜섬웨어 개발자가 공격자에게 랜섬웨어를 판매/임대하는 사업 모델이다"
      ],
      "answer": 3,
      "explanation": "RaaS는 랜섬웨어 개발자가 공격자(어필리에이트)에게 랜섬웨어를 판매하거나 수익을 공유하는 사업 모델입니다. REvil, LockBit 등이 대표적입니다.",
      "keywords": [
        "RaaS",
        "랜섬웨어",
        "사업 모델"
      ]
    },
    {
      "id": 27,
      "question": "내부자 위협 대응을 위해 사용자와 개체의 행위를 분석하여 이상 징후를 탐지하는 기술은?",
      "options": [
        "SIEM",
        "NAC",
        "DLP",
        "UEBA"
      ],
      "answer": 3,
      "explanation": "UEBA(User and Entity Behavior Analytics)는 사용자와 개체의 정상 행위 기준선을 학습하고, 이로부터의 편차를 탐지하여 내부자 위협을 발견합니다.",
      "keywords": [
        "UEBA",
        "내부자 위협",
        "행위 분석"
      ]
    },
    {
      "id": 28,
      "question": "Blind SQL Injection에서 응답 시간의 차이를 이용하여 데이터를 추출하는 방식은?",
      "options": [
        "Error-based",
        "Union-based",
        "Time-based Blind",
        "Boolean-based Blind"
      ],
      "answer": 2,
      "explanation": "Time-based Blind SQL Injection은 SLEEP() 같은 시간 지연 함수를 사용하여, 조건이 참일 때 응답이 지연되는 것으로 데이터를 한 비트씩 추출합니다.",
      "keywords": [
        "Time-based Blind",
        "SLEEP",
        "SQL Injection"
      ]
    },
    {
      "id": 29,
      "question": "Linux 권한 상승에서 PATH 환경 변수를 조작하여 악성 바이너리를 먼저 실행시키는 기법은?",
      "options": [
        "PATH 하이재킹",
        "LD_PRELOAD",
        "커널 익스플로잇",
        "SUID 악용"
      ],
      "answer": 3,
      "explanation": "PATH 하이재킹은 PATH 환경 변수에 공격자가 제어하는 디렉토리를 추가하여, 정상 바이너리 대신 악성 바이너리가 먼저 실행되도록 합니다.",
      "keywords": [
        "PATH 하이재킹",
        "권한 상승",
        "환경 변수"
      ]
    },
    {
      "id": 30,
      "question": "CSRF와 XSS의 차이에 대한 설명으로 옳은 것은?",
      "options": [
        "CSRF는 서버 취약점이고, XSS는 네트워크 취약점이다",
        "둘 다 동일한 공격이다",
        "CSRF는 사용자의 인증된 세션을 악용하고, XSS는 클라이언트에서 악성 스크립트를 실행한다",
        "CSRF는 클라이언트에서 스크립트를 실행하고, XSS는 서버에 요청을 위조한다"
      ],
      "answer": 4,
      "explanation": "CSRF는 사용자의 인증된 세션을 악용하여 의도하지 않은 요청을 보내는 공격이고, XSS는 클라이언트 브라우저에서 악성 스크립트를 실행하는 공격입니다.",
      "keywords": [
        "CSRF",
        "XSS",
        "차이점"
      ]
    },
    {
      "id": 31,
      "question": "메모리 포렌식 도구로, 메모리 덤프에서 프로세스, 네트워크 연결, 악성코드 등을 분석하는 것은?",
      "options": [
        "FTK",
        "Sleuth Kit",
        "Volatility",
        "Autopsy"
      ],
      "answer": 4,
      "explanation": "Volatility는 메모리 포렌식 프레임워크로, 메모리 덤프에서 프로세스 목록, 네트워크 연결, 레지스트리, 악성코드 등을 분석합니다.",
      "keywords": [
        "Volatility",
        "메모리 포렌식",
        "분석"
      ]
    },
    {
      "id": 32,
      "question": "DLL Hijacking 공격에 대한 설명으로 옳은 것은?",
      "options": [
        "DLL 파일을 암호화하는 공격이다",
        "Windows의 DLL 검색 순서를 악용하여 악성 DLL을 로드시키는 공격이다",
        "Linux의 공유 라이브러리를 삭제하는 공격이다",
        "DLL 파일의 디지털 서명을 위조하는 공격이다"
      ],
      "answer": 1,
      "explanation": "DLL Hijacking은 Windows의 DLL 검색 순서(현재 디렉토리, 시스템 디렉토리 등)를 악용하여 정상 DLL 대신 악성 DLL이 로드되도록 하는 공격입니다.",
      "keywords": [
        "DLL Hijacking",
        "DLL 검색 순서",
        "Windows"
      ]
    },
    {
      "id": 33,
      "question": "포맷 스트링(Format String) 취약점에 대한 설명으로 옳은 것은?",
      "options": [
        "printf 등의 포맷 문자열을 사용자 입력으로 제어할 수 있는 취약점이다",
        "정수 범위를 초과하는 취약점이다",
        "HTML 태그를 삽입하는 취약점이다",
        "SQL 쿼리에 특수문자를 삽입하는 취약점이다"
      ],
      "answer": 4,
      "explanation": "포맷 스트링 취약점은 printf, sprintf 등의 함수에서 포맷 문자열을 사용자가 직접 제어할 수 있을 때, %x, %n 등을 이용하여 메모리를 읽거나 쓸 수 있습니다.",
      "keywords": [
        "포맷 스트링",
        "printf",
        "버퍼 오버플로우"
      ]
    },
    {
      "id": 34,
      "question": "크립토재커(Cryptojacker)의 목적은?",
      "options": [
        "파일을 암호화하여 금전을 요구한다",
        "피해자의 시스템 자원으로 암호화폐를 채굴한다",
        "암호화 키를 탈취한다",
        "암호화 통신을 해독한다"
      ],
      "answer": 1,
      "explanation": "크립토재커는 피해자의 CPU/GPU 자원을 무단 사용하여 암호화폐(비트코인, 모네로 등)를 채굴하는 악성코드입니다. 웹사이트나 악성코드를 통해 배포됩니다.",
      "keywords": [
        "크립토재커",
        "암호화폐 채굴",
        "악성코드"
      ]
    },
    {
      "id": 35,
      "question": "MITRE ATT&CK에서 공격자가 초기 침투 후 재부팅이나 재로그인 후에도 접근을 유지하는 전술은?",
      "options": [
        "Defense Evasion",
        "Execution",
        "Persistence",
        "Initial Access"
      ],
      "answer": 2,
      "explanation": "Persistence(지속성)는 공격자가 시스템 재시작 후에도 접근을 유지하기 위한 전술입니다. 레지스트리 Run 키, 서비스, 크론 작업 등을 이용합니다.",
      "keywords": [
        "Persistence",
        "지속성",
        "MITRE ATT&CK"
      ]
    }
  ]
}